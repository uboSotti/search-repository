이제 새로운 프로젝트를 시작 할꺼야. Android 앱 기본 골격을 만들어 보자.
아키텍처는 구글의 권장 아키텍쳐를 따라 multi module 로 구성을 할꺼고.
Hilt 를 사용해 모듈들을 연결 시켜 줄꺼야.
우선 기본 안드로이드 앱 의 기본 프로젝트 구조를 추가하는 걸로 작업을 시작해 보자.
기본 빌드가 되는 것까지 해야할 일들을 목표를 우선 새우고. 절차대로 진행할꺼야.

앱 이름은 KurlyExam.
application id 는 com.kurly.exam.jnsk

로 생성 해줘

----

 @libs.versions.toml  파일을 보고 최적화 시켜줘
그리고, 각  build.gradle.kts 파일들에 의존성을 업데이트 시켜주고. 라이브러리들 버전 또한 최신화 시켜줘

----

Unable to load class 'com.google.devtools.ksp.gradle.KspTaskJvm'
com.google.devtools.ksp.gradle.KspTaskJvm

이런 오류를 내면서 빌드가 안되고 있는데 이유를 찾아줘
----

지금 생성된 featrue:search 모듈의 이름을 main 으로 변경해줘

----

이제 feature:main 에 우리 앱의 기본 화면을 만들꺼야.
Compose 를 활용해서 개발할꺼고 최신 안드로이드 16 개발 기준에 맞춰 테마를 재구성 해야해.
가령 edge to edge 같은 가이드를 준수 해줘야.

그리고, 아래 가이드에 맞도록 기본 화면을 생성해줘

1. 앱이 켜질때 main 모듈에 있는 화면에 노출되도록 수정을 하고.
2. 첨부한 이미지를 참고하여, 기본 화면 및 컴포넌트들을 제작해줘. #제공받은 이미지 첨부
3. 각 종 색상이나 사이즈들은 공통 컴포넌트를 최대한 활용하며, 없는 경우 기본 골격에 맞춰 추가해줘

----

니가 추가한 coil3 이 새로 나왔다고 확인 했는데 그 기준에 맞춰 새롭게 추가 해줘

----

현 상태에서 두가지 문제를 해결 해야해 Hilt 의 navigation-compose 디펜던시가 누락된 걸로 확인 되고, Icons 라이브러리 사용법이 변경된 걸로 확인 되었어. 두가지 문제를 확인하고 빌드가 되어 앱이 실행 가능한 상태까지 진행해줘

----

우선 잘못 수정된 부분을 정정할게,

The hiltViewModel() APIs for Compose have been moved to a new artifact (androidx.hilt:hilt-lifecycle-viewmodel-compose) and package (androidx.hilt.lifecycle.viewmodel.compose) such that they can be used without transitively depending on androidx.navigation.

참고해서 다시 반영해줘

----

그리고 Icons 는 androidx.compose.material:material-icons-core 라는 의존성을 가져야 하는 걸로 보이는데, 관련해서 내용 검색해 보고 의존성을 해결해줘

----

첨부한 이미지를 보면 상품 아이템에는 찜하기 여부가 존재 하는데, 너의 구현에서는 누락된걸로 확인된다. ( # 가이드 문서 다시 추가 )

ic_btn_heart_on.xml
ic_btn_heart_off.xml

두 이미지를 활용해, 상태에 따라 해당 값을 노출하도록 추가 해줘.

----

이제 네트워크 연결을 시작해 보자.

우선 우리가 사용할 라이브러리는 OkHttp 와 Retrofit 을 사용할 거야.
Hilt 를 활용해 Okhttp client 와 retrofit 의 interface 는 Hilt 의 모듈로 별도 network 모듈에 추가 해줘

그리고 추가해둔 :core:mockserver 를 활용해 api 를 테스트 할꺼야.

첫번째로.
- OkHttp 에 MockInterceptor 를 추가 해둬야하해
- Api 는 아래 내용을 참고해서 SectionApi 인터페이스에 retrofit service 로 만들어줘.
- 각 api 응답값에 맞는 데이터 모델을 생성해줘

BaseUrl : https://kurly.com/

1. sections api
섹션 목록 불러오기 ( “sections")
- query - page: Int
* type 에 따라 뷰타입을 나누고, id 에 따라서 각각의 섹션의 상품목록을 보여주도록 하자.
데이터 모델 참고 파일 (sections_1.json)

2. section products api
섹션 별 상품 목록상품 데이터 (“section/products")
- query - sectionId : Int
데이터 모델 참고 파일 (section_products_7.json)

둘째로.
- SectionRepository 를 생성해 해당 SectionApi 를 hilt 모듈로 주입 받아 데이터를 전달 받을 수 있어야해
- 각 Api 별로 UseCase 를 도메인 레이어에 추가 해줘.
- MainViewModel 에서 생성된 UseCase 를 참조해 데이터 흐름을 만들어줘

여기 까지 작업을 진행할껀데 어떤 순서로 진행할건지 절차를 우선 나에게 보여주고 우선순위에 맞춰 하나씩 전행 해보자.

* 파일 추가 규칙
- 현재 생성된 프로젝트 아키텍처 MVVM 에 맞게 옳바른곳에 생성해줘야해.

----

좋아. 지난 과정에서 우리가 놓친 것들을 확인 해볼꺼야.

1. data 모듈에 의존성이 누락된 부분들이 있어.
2. mockserver 모듈의 의존성이 누락된 부분 들이 있어.
3.  @libs.versions.toml  파일을 다시 한번 최적화 해서 각 모듈들의 디펜던시를 정리 해보자

----

e: file:///C:/Users/jnsk8/AndroidStudioProjects/search-repository/feature/main/src/main/java/com/kurly/exam/feature/main/MainScreen.kt:8:35 Unresolved reference 'Icons'.

이번에 니가 수정한 내용에 오류가 있어.

import androidx.compose.material3.Icons

를 활용하면서 생기는 이슈 인데, 이부분은 라이브러리를 잘못 이해하고 있어서 생기는 문제 이고,

import androidx.compose.material.icons.Icons

를 참조 하면 해결할 수 있는 문제야. 관련해서 다른 부분에도 관련 문제가 없는지 확인해 보고. 현재 내가 해둔 version catalog 를 참조해서 관련 부분도 정리해줘

:mockserver 의 의존성이 여전히 해결되지 않고 있어.
 @AssetFileProvider.kt  의 의존성을 해결해줘
:data 모듈에  @SectionApi.kt 의 의존성 이슈를 해결해줘.

----

네트워크 관련 작업도중 멀티 모듈의 의존성 그래프가 꼬여있는 걸로 확인이 되고 있어.
그와 함께 hilt 의 모듈 정의 파일들도 서로의 위치를 정확하게 지키지 못하고 있어.

참고로,  @NetworkModule.kt  파일에서 sectionApi 의 정의는 data 모듈에 선언 되어 있어야 하는 걸로 보이는데 다른 곳에 존재 하야 빌드에 실패를 하고 있어.
관련해서 생성된 파일들이 아래 권장 사항이 쓰여 있는 링크 내용에 맞도록 수정해줘

https://developer.android.com/topic/architecture/recommendations.md.txt

----

지금 공통적으로 유사한 문제들이 발생중인데, Gson 에 대한 의존성 문제들이 발생하고 있어.

여기서 우린 한가지 문제를 해결하고 넘어간다.

Gson 의 사용을 버리고 Kotlin 의 kotlinx.serialization 의 json 을 활용하는 것으로 전면 교체 작업을 시작하자.

그리고 여기 Retfofit 에서 추천 하는 사용 설명서가 있어 참고해서 마이그레이션이 필요한 부분들을 수정해줘
https://raw.githubusercontent.com/square/retrofit/refs/heads/trunk/retrofit-converters/kotlinx-serialization/README.md

----

 @libs.versions.toml  을 구성을 좀 더 가독성이 좋도록 각 섹션들 마다 유사 그룹 또는 사용처에 맞도록 순서를 재정렬 해주고, 네이밍도 깔끔하게 정리를 해줘

----

중요한 포인트를 하나 놓쳤다.

우린 네트워크 사용이나 UI 갱신등의 비동기 처리를 위해 Coroutine 을 사용해야 하는데 그 처리를 빠졌어.
관련 해서 대체 할 수 있는 영역들에 대해 추가 작업을 진행 하자

----

이번 할일 들은 네트워크 레이어와 데이터 레이어들이 완성되었으니 해당 레이어들의 신뢰성을 확보 할 수 있도록 테스트 환경을 만들꺼야.
지금까지 한 작업 내역들을 기반으로 주요한 기능들 위주로 테스트 코드를 작성해줘.

아래는 내가 생각했을때 필요한 구간이야. 추가로 필요한 것들도 추천 해줘.

1. 기존에 생성 되어있는 mockserver 의 테스트 코드들을 살려 작업을 진행해주고.
2. usecase 별 테스트 케이스가 필요하고.
3. 추가된 retrofit api 들의 테스트 코드들도 필요해

이제 이 작업들을 어떻게 수행할 것인지 전략을 우선 짜서 나와 검증해보고, 하나 하나 실행해보자

-> 좋아. 테스트 도구 및 환경 설정 부터 진행시켜
-> :mockserver 에 있는 기존 테스트 코드들을 우선적으로 시작하자 바닥부터 안정성을 확보해 나가자
->  @SectionApiTest.kt  빌드가 되지 않는데, 디펜던시 문제가 있는거 같아
-> 아직 문제가 해결되지 않았어.
     @SectionApiTest.kt  를 이렇게 테스트 setUp 의 방식을 좀 변경해서. hilt 를 활용하도록 변경하자. 그 방식이 실제 환경과 더 유사한 테스트 환경을 만들 수 있을거 같아
-> :mockserver 모듈에  @MockServerTest.kt  가 이미 존재하는데, 중복 테스트 파일들이 존재 하네.

   나는 androidTest 폴더에 존재하는 저 방식을 따르고 싶고, "file_read_test.json" 파일을 활용 하기를 원해.
    @TestAssetFileProvider.kt  를 이용해 셋업 해줄 수 있는 점도 참고 해줘.

   이제 :mockserver 의 테스트 들을 정리해줘 불필요한 부분들은 삭제 하면돼
----

이제 본격적으로 UI 작업을 시작할거야.

데이터에 대한 이해를 돕기 위한 이미지 파일과 main 화면에 대한 전반적인 정의가 그려진 이미지 파일 두개를 참조 했고.

1) 메인 기본
- 메인은 여러개의 섹션으로 이루어져 있다.

2) 섹션
- 아래의 sections api 에서 페이지 정보와 함께 섹션의 정보를  리스트로 내려준다.
-  섹션은 3개의 타입이 있다.
   (1)vertical : 세로 스크롤이 가능한 섹션
   (2)horizontal : 가로 스크롤이 가능한 섹션
   (3)grid : 3(col) x 2(row) 총 6개의 상품을 볼 수 있는 섹션
- 각 섹션마다 title 이 있어 상품과 별도로 노출이 필요하다.
- 한 섹션마다 여러 개의 상품이 있다.

3) 상품
- 아래의 section/products api 에서 해당 섹션에 포함된 상품목록을 내려준다.
- 상품은 vertical, grid //  horizontal  두개의 뷰가 모양이 다르다.
- 제목
  (1) horizontal, grid 형태에서는 2줄과 말줄임 처리해서 보여준다.
  (2) vertical 에서는 한줄과 말줄임 처리해서 보여준다.
- 가격
  (1) 할인이 있을 경우 할인율(#fa622f), 할인가격(bold)과 원래가격(취소선) 을 보여준다.
  (2) 할인이 없을 경우 원래가격만 노출한다.
  (3) horizontal,grid 형태에서는 첫번째 줄에 할인율, 할인가격을 보여주고, 두번째 줄에 원래가격을 보여준다.
  (4) vertical 형태에서는 한줄에 모든 가격정보를 보여준다.
*좀 더 자세한 ui 는 위의 UI 링크를 참고하자.
*모든 상품은 찜하기가 가능하다.

4) 찜하기
- 찜하기 기능은 서버 없이 구현이 필요하다.
- 찜하기 여부에 따라 찜하기 아이콘을 다르게 보여줘야한다.

5) 새로고침
- 메인화면은 pull to refresh 를 이용해서 새로고침을 제공한다.

위와 같은 요구 사항을 가지고 있어.

현재 파일을 기준으로 우리의 요구 사항을 충족 시킬 전략을 세우고 어떤 작업들을 수행하면 좋을지 리스트업 해줘.
그리고 찜하기 기능은 우선 MainViewModel 내부에서 임시로 저장하는 걸로 처리하고 TODO 로 dataStore 를 활용해 저장해야 한다고 표기 해줘

*작업시 지켜야 할 룰
- Jetpack Compose 를 활용할것.
- Jetpack library 를 가급적 활용할것.
- Compose 의 다양한 최적화 기법들을 활용해 recomposition 을 최소하 시킬 수 있는 방안을 고려한다.
- 컴포넌트화 시킬 수 있는 항목들을 잘 분리해 커버리지를 높인다.
- 심미적인 것들을 고려한 요소들을 추가해도 좋다.

----

동작은 확인 했어.

이제  현재파일에서 수정할 부분들을 얘기 할게.
- 장바구니 기능은 요구사항에 없음으로 삭제
- 불필요한 주석 제거 할것
- 필요한 구간에는 remember{} 활용해 리컴포즈 가 발생할때 성능 최적화에 이점을 주기
- 가독성을 높이기 위한 작업들을 추가로 실행 할것.
 a. SectionHeader() 을 LazyListScope.SectionHeader() 로 만들어서 함수 안으로 item(..) { ... } 을 넣어서 처리 할것
 b. 각종 Padding 또는 마진 등의 상수 숫자들은 별도의 값으로 분리해 static 상수화 시킬것.
 c. 가급적 생성되는 색상등은 MaterialTheme.colorScheme 을 활용해 처리 할것.
- 상품을 클릭하면, 새로운 창이 열릴수 있는 구조로 만들것.
- 가급적 확장성 있는 구조로 만들어 다음 수정에 대비 할것

----

추가 수정할 내역을 얘기 할께.

1.  @ProductItem.kt  에서 Coil3 을 활용한 이미지 표시를 시도하고 있는데, 잘못된 가이드를 참고 한거 같아서. 내가 올바른 가이드를 첨부해 줄게.
https://coil-kt.github.io/coil/getting_started/

2. typography 나 textStyle 을 copy 해서 사용할때는 private static 상수화 시켜서 사용하도록 개선해줘.

3.  @SectionHeader.kt  파일에는 우리가 이야기 했던 개선점들이 반영 되어 있지 않아 다시 한번 :main 모듈을 탐색해 빠진 파일들이 없는지 확인 해줘

----

하드코딩된 text 들을 strings.xml 로 이관 시키는 작업들을 진행해줘.

생성할때 주의할 점은 기본 언어는 en 이고 번역본으로 kr 을 추가 해서 다국어 지원이 될 수 있도록 추가 해줘

----

Coil3 를 활용해 이미지를 표시하는 방법에 대해 수정할 걸 다시 한번 요청할게.
'''
AsyncImage(
    model = "https://example.com/image.jpg",
    contentDescription = null,
)
'''
위 와 같이 사용하면 되고.

우리가 시도하던 crossfade 는 아래 참조 처럼 Application 에 인터페이스로 처리 해줘야해.

'''
class CustomApplication : Application(), SingletonImageLoader.Factory {
    override fun newImageLoader(context: Context): ImageLoader {
        return ImageLoader.Builder(context)
            .crossfade(true)
            .build()
    }
}
'''

참고해서 수정 작업 진행해줘

* 가이드 링크
https://coil-kt.github.io/coil/getting_started/

----

새로운 작업을 시작해 보자.

이번엔 Main UI 수정 부터 모델들 까지 모두 건드려야 하는 복잡한 작업이 될꺼야.
현재 SectionApi 에 getSections() 를 보면 page 를 전달하게 되어 있어.
Main 화면에서도 그 부분을 추가로 개발할꺼야. main 을 스크롤 해 반 이상을 스크롤을 할 경우  다음 페이지를 요청해 데이터를 추가로 읽어 와야해. 페이징 처리가 필요한 부분이지.

여기서 우리는 Jetpack 의 paging3 를 활용해 보자.

시작해보자.

-> 버그를 발견했어.

    @SectionDto.kt  파일에 SectionsResponse.paging 은 nullable 데이터야 참고해서 개선해줘

----

이제 이번 작업을 커밋하기 전에 최종적으로 우리의 규칙들에 위배되는 사항이 없는지 다시 한번 검토해보고 개선할 점들이 있으면 알려줘

 -> 방금 수정한 내역들중에 아래 오류가 있는 부분들이 있네, 재검토 해보고 전체 이상 없는데 한번도 확인해줘
    1.  @MainScreen.kt  에서 LazyColumn 아이템 정의 코드 오류
----

이번에는 찜하기의 저장소를 만드는 작업을 진행하자.

* 요구 사항
- 로컬 저장 방식이어야 하고.
- 앱을 다시 시작 했을때도 저장이 되어 있어야함.
- 찜하기한 동일한 상품이 화면에 보이는 경우 함께 업데이트 되어야 함.

*지켜야 할점
- 프로젝트의 아키텍쳐 레이어 구조에 맞게  만들어야함
- Jetpack 의 라이브러리를 활용하면 더 높은 점수를 받음.

----

이제 그럼 FavoriteRepository 의 안정성을 위한 테스트 코드를 작성해보자
 -> FavoriteRepositoryImplTest -> FavoriteRepositoryTest 로 이름을 가져가고 hilt 를 활용해 실제 주입 받는 걸 추가해서 진행해줘

----

이번에는 앞으로 추가될 모듈들의 빌드 컨벤션을 위한 사전 작업 들을 진행 할꺼야.

GradlePlugin 을 활용한 build.gradle.kts 파일의 표준화 작업이라고 볼수 있지.

현재 모듈들은 대략적으로
- JVM 모듈
- AndroidLibrary 모듈
- UI 가 있는 Feature 모듈
- App 모듈

이렇게 존재 해

너의 판단으로 공통 묶음을 찾아 컨벤션을 추가로 만들고 prebuild 단에 빌드 로직을 추가하여 컨벤션 플러그인 을 각 빌드 스크립트에 적용해 보자

 -> :build-logic 을 추가 할때 include 가 아니고  includeBuild 을 사용하는 걸로 수정해서 진행하자.
 -> (중단 후)https://blog.yjyoon.dev/android/2025/03/31/android-gradle-convention/

          https://velog.io/@trasalby/Gradle-Kotlin-%EC%BB%A8%EB%B2%A4%EC%85%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%AA%A8%EB%93%88-%EA%B4%80%EB%A6%AC-3-Custom-Plugin-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0

          GradePlugin 을 전혀 만들줄 모르는거 같아서 두 링크를 가져왔어.
          참고 해서 전략을 새롭게 작성하고 준비해 보자

 -> 이제 추가로 작업할 것들이야.

    1. 과도한 은닉으로 명시적으로 어떤 플러그인이 설치 되어 있는지 알기 어렵네.
     - AndroidApplicationCompose
     - AndroidLibraryCompose
    와 같은 방식으로 컴포즈를 사용하는 패턴은 분리하여 플러그인을 새로 추가 해주고 각 모듈에 직접 반영해줘
    유사한 패턴의 항복들이 있다면 증식 해서 진행해줘

    2.  @AndroidCompose.kt  파일을 하나 생성 해뒀어. 플러그인 여기저기에 흩어져 있는 configure 들을 모아서 처리해줘
    필요에 따라 클래스를 추가 해주고.

----

이번엔 :app 모듈에 App Composable 을 추가 할꺼야.

Jetpack navigation3 를 활용하여 만들고,
MAIN -> feature:main 모듈이 활용 되도록 추가 할꺼야.

sealed interface Screen {}

#참고 링크
https://developer.android.com/jetpack/androidx/releases/navigation3#1.0.0
https://android-developers.googleblog.com/2025/05/announcing-jetpack-navigation-3-for-compose.html

 -> https://developer.android.com/guide/navigation/navigation-3/get-started
    https://developer.android.com/guide/navigation/navigation-3/basics
    두 링크를 읽고 앱 네이게이션 정책을 새워봐

----

다음 작업은 앱 하단에 바텀 메뉴바를 만들꺼야.

 @ExamApp.kt  안에서 만들어 나가면되고, 메뉴 구성은 Main 과 Favorite 이야

Main -> MainRoute
Favorite -> FavoriteRoute

두 메뉴를 누를 때마다 바뀌도록 navigation 정의를 해주면 돼
메뉴가 바뀔때는 이전 상태를 기억 하도록 해야해


그다음 작업은 FavoriteRoute 가 들어 있는 :feature:favorite 모듈을 만들어야해 아래는 해당 모듈의 기능이야

#favortie 화면 정의
- 2x2 grid 형식
- Main 에서 찜하기 한 상품이 노출 되어야 한다
    a. FavoriteRepository 의 데이터를 활용하고.
    b. FavoriteViewModel 을 생성해서 추가 할것
- ui  형태는 main 의 Product 와 공유 할것.

# 기능 정의
- 찜하기를 해제 할 수 있으며 해제하면 바로 리스트에서 사라져야함


이제 전략을 세워봐

  -> 1. Main 모듈에서 찜하기 수행시
      -> Product 를 로컬에 저장 ( FavoriteRepository )

     2. Favorite 모듈에서는 로컬에 저장된 Product 를 활용해 리스트를 보여준다

     3.  @FavoriteRepositoryImpl.kt  에서 로컬에 저장할때는 dataStore 를 활용해 저장하도록 구현해줘

     로 전략을 수정할게
----

이제 주석 작업을 해보자.

- 각 퍼블릭 함수
- 인터페이스 함수
- 데이터 모델
- 복잡도가 높은 로직

등 의미가 있지만 누락된 곳에 주석 또는 doc을 달아줘.
가급적 한국어로 작성되어야해